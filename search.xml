<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MEPER-Cloud 计划</title>
      <link href="/2023/07/27/MEPER-Cloud-%E8%AE%A1%E5%88%92/"/>
      <url>/2023/07/27/MEPER-Cloud-%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>MEPER-Cloud 整体项目还需要处理的任务。</p><span id="more"></span><h3 id="1、WebSite-调用后端接口的梳理"><a href="#1、WebSite-调用后端接口的梳理" class="headerlink" title="1、WebSite 调用后端接口的梳理"></a>1、WebSite 调用后端接口的梳理</h3><a href="/2023/07/26/Vue-Portal-MEPER%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/" title="Vue Portal MEPER调用关系">Vue Portal MEPER调用关系</a><blockquote><p>Layla </p></blockquote><h3 id="2、MEPER-Cloud-的PageEditor-数据标识"><a href="#2、MEPER-Cloud-的PageEditor-数据标识" class="headerlink" title="2、MEPER-Cloud 的PageEditor 数据标识"></a>2、MEPER-Cloud 的PageEditor 数据标识</h3><a href="/2023/07/26/PageEditor%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AF%86/" title="PageEditor数据标识">PageEditor数据标识</a><blockquote><p>Jimmy</p></blockquote><h3 id="3、website-管理员审核后台（企业认证审核）"><a href="#3、website-管理员审核后台（企业认证审核）" class="headerlink" title="3、website 管理员审核后台（企业认证审核）"></a>3、website 管理员审核后台（企业认证审核）</h3><h3 id="4、MEPER-Cloud-对应的项目页面重构"><a href="#4、MEPER-Cloud-对应的项目页面重构" class="headerlink" title="4、MEPER-Cloud 对应的项目页面重构"></a>4、MEPER-Cloud 对应的项目页面重构</h3><p>目前 project 和 工作空间 概念混淆，之前的 Project 的结构需要兼容当前的逻辑，所以 project 项目页面是否需要重构</p><h3 id="5、MEPER-Cloud-数据备份页面"><a href="#5、MEPER-Cloud-数据备份页面" class="headerlink" title="5、MEPER-Cloud 数据备份页面"></a>5、MEPER-Cloud 数据备份页面</h3><p>当前数据备份页面可以导入导出 Project ，而Project又混淆工作空间的概念，所以是不合理的，应当是导入导出的话不可以有 Project 数据污染。</p><h3 id="6、MEPER-Cloud-需要改造管理项中的-User-页面"><a href="#6、MEPER-Cloud-需要改造管理项中的-User-页面" class="headerlink" title="6、MEPER-Cloud 需要改造管理项中的 User 页面"></a>6、MEPER-Cloud 需要改造管理项中的 User 页面</h3><p>逻辑进行优化，user页面应该需要查看当前公司下的所有 User 信息，然后进行工作空间的切换，目前是可以支持，登录 User 本人进行空间切换，但是操作反锁且不合理，需要优化成管理员操作 User 的空间切换，并且可以在对应空间中给 User 绑定角色。</p><h3 id="7、MEPER-Cloud-需要在管理项中新增一个工作空间管理页面"><a href="#7、MEPER-Cloud-需要在管理项中新增一个工作空间管理页面" class="headerlink" title="7、MEPER-Cloud 需要在管理项中新增一个工作空间管理页面"></a>7、MEPER-Cloud 需要在管理项中新增一个工作空间管理页面</h3><p>管理页面可以更新创建对应工作空间，可以在管理页面进行工作空间切换。还有打包 Project 生成 App ，也就是创建 Application，和后续 Application 的后续操作逻辑。</p><h3 id="8、Website-更新的页面优化，还有管理员后台的页面等"><a href="#8、Website-更新的页面优化，还有管理员后台的页面等" class="headerlink" title="8、Website 更新的页面优化，还有管理员后台的页面等"></a>8、Website 更新的页面优化，还有管理员后台的页面等</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue Portal MEPER调用关系</title>
      <link href="/2023/07/26/Vue-Portal-MEPER%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
      <url>/2023/07/26/Vue-Portal-MEPER%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>整理一下整体的调用链路和设计。</p><p>目前整理流程暂时分为四个服务</p><blockquote><p>Website<br>Portal<br>Linux MEPER<br>Window MEPER</p></blockquote><span id="more"></span><h2 id="Vue-Website"><a href="#Vue-Website" class="headerlink" title="Vue Website"></a>Vue Website</h2><p>首先确认Website大概有多少的调用请求</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><blockquote><p>Portal</p></blockquote><p>用户注册逻辑，请求设计是Website请求到Portal，注册成一个用户，需要继续进行引导去做企业认证。</p><p>需要处理的点是，如果是用户没有进行企业认证的话，或者没有认证审核通过的话，不能直接通过MEPER登录，也就是说MEPER的用户需要在当前的用户进行了企业认证而且在企业认证审核通过之后才可以登录。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><blockquote><p>Portal</p></blockquote><p>用户登录到Portal进行一些简单的信息查看和跳转等等， 但是在没有进行企业认证的情况下，没有办法进行下载和其他的操作。</p><p>如果点击了相关下载功能等，需要进行跳转和引导进行企业认证。</p><p>需要处理的点，目前如果是从Portal登录后，会自动去MEPER调用登录接口，请求MEPER的token，这一块需要加一个判断进行处理，如果没有企业认证的话，不需要拿token。</p><h3 id="更新用户信息"><a href="#更新用户信息" class="headerlink" title="更新用户信息"></a>更新用户信息</h3><blockquote><p>Portal</p></blockquote><p>更新用户的基本信息，目前用户名是不支持更新的，即使后期可以改，也要进行唯一性验证。</p><h3 id="企业认证"><a href="#企业认证" class="headerlink" title="企业认证"></a>企业认证</h3><blockquote><p>Portal</p></blockquote><p>注册公司信息，还是仅仅在Portal中处理这部分逻辑，创建公司信息还是在Portal处理。</p><h3 id="更新企业信息"><a href="#更新企业信息" class="headerlink" title="更新企业信息"></a>更新企业信息</h3><blockquote><p>Portal</p></blockquote><p>更新注册的公司信息还是在Portal包括管理员进行审核和状态变更。</p><blockquote><p>Linux MEPER</p></blockquote><p>需要处理的点，当企业认证信息被审核通过后，才去MEPER进行信息的同步，也就是企业认证审核通过后用户才可以通过MEPER的链接直接进行登录操作</p><h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><p>逻辑变更后，创建工作空间的请求直接到MEPER。</p><blockquote><p>Window MEPER</p></blockquote><p>需要处理和确认的点<br>请求到MEPER的时候需要先获取到MEPER的token，然后才能去请求的MEPER的接口，还有一点，请求的参数中的UserId或者CompanyId的信息，需要使用的是MEPER表里面的对应的ID。</p><h3 id="更新工作空间"><a href="#更新工作空间" class="headerlink" title="更新工作空间"></a>更新工作空间</h3><blockquote><p>Linux MEPER</p></blockquote><p>同上直接请求MEPER的接口，需要注意在header中拼装上对应的token调用。</p><h3 id="查询工作空间"><a href="#查询工作空间" class="headerlink" title="查询工作空间"></a>查询工作空间</h3><blockquote><p>Linux MEPER</p></blockquote><h3 id="创建App"><a href="#创建App" class="headerlink" title="创建App"></a>创建App</h3><blockquote><p>Window MEPER</p></blockquote><h3 id="更新App"><a href="#更新App" class="headerlink" title="更新App"></a>更新App</h3><blockquote><p>Linux MEPER</p></blockquote><h3 id="查询App"><a href="#查询App" class="headerlink" title="查询App"></a>查询App</h3><blockquote><p>Linux MEPER</p></blockquote><h3 id="下载App"><a href="#下载App" class="headerlink" title="下载App"></a>下载App</h3><blockquote><p>Window MEPER</p></blockquote><h3 id="拓展的App评论"><a href="#拓展的App评论" class="headerlink" title="拓展的App评论"></a>拓展的App评论</h3><blockquote><p>Linux MEPER</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PageEditor数据标识</title>
      <link href="/2023/07/26/PageEditor%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AF%86/"/>
      <url>/2023/07/26/PageEditor%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>ExportTab 页面导出数据的backup逻辑中，特殊处理一下PageEditor数据，导出的PageEditor带有当前APP的标识，当前的Project如果没有打包App的话，则当前的PageEditor数据标识还是存的上一个App的标识。</p><span id="more"></span><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>目前License针对的是每种套件的SDK接口层进行验证，但是创建了Project之后，在MEPER-Cloud环境中，是默认可以使用所有的SDK接口参数的，我们的套件的主要逻辑又是基于PageEditor数据的，所以将当前Project的依赖逻辑处理标识放在PageEditor数据中，增加当前PageEditorEntity中标注出当前的页面是从哪个套件或者App中导出的，作为一个可追溯来源的标识。</p><h2 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h2><p>针对PageEditorEntity模型新增两个字段，一个是来源App标识（SourceApp），一个是当前App标识(CurrentApp)。</p><h3 id="SourceApp"><a href="#SourceApp" class="headerlink" title="SourceApp"></a>SourceApp</h3><p>项目创建的时候会选择空项目或者是基于MES的项目这种情况，则数据包中对应的PageEditor数据中，数据AppBase的这部分数据对应的SourceApp字段就是AppBase，若是选择的MES项目的话，则对应数据包中，AppBase部分的PageEditor数据对应的字段就是AppBase，而在MES中新增的PageEditor数据对应的SourceApp字段则为MES。</p><h3 id="CurrentApp"><a href="#CurrentApp" class="headerlink" title="CurrentApp"></a>CurrentApp</h3><p>当前字段的逻辑设计是为了追溯当前PageEditor数据来源设计的，当一个项目创建的时候，基于哪个App的数据包进行初始化的时候，则SourceApp就是去找对应的CurrentApp进行赋值。若是Project没有进行打包App处理的话，直接通过数据备份进行导出话，则当前CurrentApp字段为空，直接默认SourceApp就是之前的值。</p><p>如果当前的Project进行过一次打包App的话，则对应的数据中的PageEditor中对应CurrentApp字段都需要赋值为对应打包的App标识。而这个时候直接从数据备份中导出的话，则SourceApp将会自动变为当前Project创建的App的标识，导入到其他的Project中去。</p><h2 id="字段逻辑"><a href="#字段逻辑" class="headerlink" title="字段逻辑"></a>字段逻辑</h2><h3 id="套件数据"><a href="#套件数据" class="headerlink" title="套件数据"></a>套件数据</h3><p>系统默认的套件数据包中，PageEditor数据的SourceApp和CurrentApp数据都是对应套件App的标识。</p><blockquote><p>AppBase</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PageEditor:</span><br><span class="line">&#123;</span><br><span class="line">&quot;SourceApp&quot;:&quot;AppBase&quot;,</span><br><span class="line">&quot;CurrentApp&quot;:&quot;AppBase&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>MES</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PageEditor:</span><br><span class="line">&#123;</span><br><span class="line">&quot;SourceApp&quot;:&quot;MES&quot;,</span><br><span class="line">&quot;CurrentApp&quot;:&quot;MES&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="新创建的Project"><a href="#新创建的Project" class="headerlink" title="新创建的Project"></a>新创建的Project</h3><p>当用户创建新的项目基于对应的App，则对应的PageEditor数据字段应当是对应创建Project的时候的App。</p><p>例如如果是基于AppBase创建的项目：</p><blockquote><p>AppBase 创建了 Project1 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PageEditor:</span><br><span class="line">&#123;</span><br><span class="line">&quot;SourceApp&quot;:&quot;AppBase&quot;,</span><br><span class="line">&quot;CurrentApp&quot;:&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建完成后SourceApp是对应数据中的CurrentApp，而现在的CurrentApp字段则默认为空。</p><p><strong>所以按照这个逻辑处理的话，SourceApp是一直有字段的，所以在这个时候使用数据备份导出当前的PageEditor数据的话，SourceApp是数据的，导入其他的Project的话，导入逻辑如果CurrentApp字段为空的话，使用SourceApp相当于溯源到上级项目</strong></p><h3 id="Project打包了App"><a href="#Project打包了App" class="headerlink" title="Project打包了App"></a>Project打包了App</h3><p>当创建的工作空间进行了APP打包,那么在打包过程中可以通过PageEditor的SourceApp数据进行统计当前的套件使用情况，或者是来源的App情况，然后去溯源App对应的License。</p><p>而且打包过程中创建了App，则需要在数据中将PageEditor的CurrentApp字段都赋值为当前创建的App。</p><blockquote><p>Project1 打包了 App1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PageEditor:</span><br><span class="line">&#123;</span><br><span class="line">&quot;SourceApp&quot;:&quot;AppBase&quot;,</span><br><span class="line">&quot;CurrentApp&quot;:&quot;App1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以当这个时候在备份数据中导出PageEditor的话，对应的CurrentApp字段就为当前的App，那么导入到其他的Project中的话，其他的Project中对应的PageEditor字段的<br>SourceApp就变成了当前的App（也就是App1）。</p><h2 id="需求目的"><a href="#需求目的" class="headerlink" title="需求目的"></a>需求目的</h2><p>记录了所有的PageEditor的这两字段后，当Project进行数据打包的时候，就可以根据PageEditor中的SourceApp字段作为依据产生对应的License。</p><p>如果是当前的Project项目是基于系统App创建的话，那么如果PageEditor的SourceApp有AppBase或者MES那么License产生的时候，应该自动默认包含这两个部分的套件。</p><p>如果当前的Project是经过SI二次开发的，而且打包了对应的APP的话，那么SourceApp对应的字段应该可以找到对应的App，然后通过对应的App产生的License进行重新产生当前Project对应App的License。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计页面引导访问</title>
      <link href="/2023/07/24/%E8%AE%BE%E8%AE%A1%E9%A1%B5%E9%9D%A2%E5%BC%95%E5%AF%BC%E8%AE%BF%E9%97%AE/"/>
      <url>/2023/07/24/%E8%AE%BE%E8%AE%A1%E9%A1%B5%E9%9D%A2%E5%BC%95%E5%AF%BC%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>MEPER 的设计页面引导访问的流程设计。</p><p>简单设计一个流程然后后面再针对功能进行设计其他引导。</p><span id="more"></span><p><img src="/images/pasted-27.png" alt="upload successful"></p><p>针对当前设计页面做一套引导。</p><h2 id="进入页面后，先介绍几大块。"><a href="#进入页面后，先介绍几大块。" class="headerlink" title="进入页面后，先介绍几大块。"></a>进入页面后，先介绍几大块。</h2><p>1、页面左上角的标题 ，简单描述一下左上角显示的是哪些内容，还意义</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><p>2、介绍 Header 中间几个按钮的功能和具体的意义</p><p><img src="/images/pasted-26.png" alt="upload successful"></p><p>3、介绍左侧组件列表</p><p><img src="/images/pasted-28.png" alt="upload successful"></p><p>4、介绍左侧组件库</p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>5、介绍页面中间的核心设计块</p><p><img src="/images/pasted-30.png" alt="upload successful"></p><p>6、介绍中心块的设计和流程按钮</p><p><img src="/images/pasted-31.png" alt="upload successful"></p><p>7、右侧的属性模块</p><p><img src="/images/pasted-32.png" alt="upload successful"></p><p><strong>以上的介绍都是需要高亮介绍模块</strong></p><h2 id="进行一个细节引导"><a href="#进行一个细节引导" class="headerlink" title="进行一个细节引导"></a>进行一个细节引导</h2><p>以下的引导不需要进行高亮的。只要用户一边操作一边引导。</p><p>1、引导用户点击组件库的布局按钮</p><p><img src="/images/pasted-33.png" alt="upload successful"></p><p>2、引导用户拖动一个水平布局到设计模块</p><p><img src="/images/pasted-34.png" alt="upload successful"></p><p>3、引导用户点击组件库的基础按钮</p><p><img src="/images/pasted-35.png" alt="upload successful"></p><p>4、引导用户拖动一个表格组件进入水平布局</p><p><img src="/images/pasted-36.png" alt="upload successful"></p><p>5、引导用户点击设计块中的表格组件</p><p><img src="/images/pasted-37.png" alt="upload successful"></p><p>6、引导用户在右侧功能栏中点击数据源</p><p><img src="/images/pasted-38.png" alt="upload successful"><br>7、引导用户点击绑定数据源</p><p><img src="/images/pasted-39.png" alt="upload successful"></p><p>8、引导用户绑定一个数据源</p><p><img src="/images/pasted-40.png" alt="upload successful"></p><p>9 引导用户点击绑定系统对象</p><p><img src="/images/pasted-41.png" alt="upload successful"><br>10、选择 User</p><p><img src="/images/pasted-42.png" alt="upload successful"><br>11、保存</p><p><img src="/images/pasted-43.png" alt="upload successful"><br>12、点击生成子项目</p><p><img src="/images/pasted-44.png" alt="upload successful"><br>13、选择getname 并输入 文本</p><p><img src="/images/pasted-45.png" alt="upload successful"><br>14、点击保存按钮</p><p><img src="/images/pasted-46.png" alt="upload successful"><br>15、点击 header 保存按钮</p><p><img src="/images/pasted-47.png" alt="upload successful"><br>16、点击 header 预览按钮</p><p><img src="/images/pasted-48.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MEPER License</title>
      <link href="/2023/07/22/MEPER-License/"/>
      <url>/2023/07/22/MEPER-License/</url>
      
        <content type="html"><![CDATA[<p>因为MEPER-Cloud 后面要拓展所有的套件，所以 license 校验逻辑需要重新设计。</p><span id="more"></span><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>license 重新设计的原因MEPER-Cloud 当创建完项目后，是支持所有的套件SDK 调用的，所以在 MEPER-Cluod 中进行开发，不能很好的进行 SDK 使用的监控。</p><p>所以想办法将校验的 license 对应套件的方式，转到下载 APP 启动服务之后，对应 SI 或者企业申请了license，我们将对套件的 SDK 进行拦截检查。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>之前的 license 是对应公司加上多个 App 也就是不同的套件。但是 MEPER-Cloud 之后，所有的套件将会冗余到一个项目中，所以要针对不同的 SDK 进行 license 标识。</p><p>参考之前的 license aspect 切片，是针对有所有的 IHandler 进行 Around 切面，虽然能够拦截所有的 SDK 的 service，但是没办法针对套件进行区分，所以目前的设计是，针对不同套件的 SDK 进行分类，然后定义针对不同套件的 license aspect 切面，然后共同继承同一个校验 License 的 Base Validator，从而对当前 license 文件是否有效进行验证。</p><h2 id="需求明细"><a href="#需求明细" class="headerlink" title="需求明细"></a>需求明细</h2><h3 id="1、BaseValidator"><a href="#1、BaseValidator" class="headerlink" title="1、BaseValidator"></a>1、BaseValidator</h3><p>能否复用之前的 License loader 的校验逻辑进行处理。</p><h3 id="2、套件的-aspect"><a href="#2、套件的-aspect" class="headerlink" title="2、套件的 aspect"></a>2、套件的 aspect</h3><p>不同的套件的切面逻辑，是否能够抽象，在 framework 中定义，然后不同的套件进行实现和重写， 从而进行套件 SDK 的区分。</p><h3 id="3、在线-license-校验升级离线"><a href="#3、在线-license-校验升级离线" class="headerlink" title="3、在线 license 校验升级离线"></a>3、在线 license 校验升级离线</h3><p>参考之前的逻辑，或者重新设计，怎么处理从在线校验到离线 license 校验的过程。</p><h2 id="业务描述"><a href="#业务描述" class="headerlink" title="业务描述"></a>业务描述</h2><p>license初版设计.png<br><img src="/images/pasted-23.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>App生成服务</title>
      <link href="/2023/07/22/App-%E5%AE%89%E5%85%A8%E7%94%9F%E6%88%90/"/>
      <url>/2023/07/22/App-%E5%AE%89%E5%85%A8%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>window server 产生 exe 文件服务的调整</p><span id="more"></span><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>打包生成的 exe 脚本执行需要windows server 环境，最初的设计是重新封装一个 springboot 服务进行打包，不熟到 windows server 服务器，但是考虑到没必要进行太多次的网络请求，浪费流量成本和网络时间开销，所以目前重新设计，将打包 exe 逻辑接口迁移到 MEPER 服务中， MEPER 暂定部署两个节点，一个 docker  Linux 节点，一个 windows server 节点。</p><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>将打包 exe 脚本接口迁移到 MEPER 中，然后将 portal 调用 MEPER 的接口分成两部分，直接配置指向对应 IP，将 project 打包导出文件接口和 App 封包 exe 接口都去请求Windows server 的服务，则对应产生的 App 数据包和对应的 Inno setup 脚本都在同一个 windows server 服务器，进一步减少网络开销，且当前 windows server 的 MEPER 只去处理文件相关的接口，减轻对应的业务逻辑。</p><h2 id="逻辑时序图"><a href="#逻辑时序图" class="headerlink" title="逻辑时序图"></a>逻辑时序图</h2><p><img src="/images/pasted-22.png" alt="upload successful"></p><h2 id="需求明细"><a href="#需求明细" class="headerlink" title="需求明细"></a>需求明细</h2><h3 id="1、接口迁移"><a href="#1、接口迁移" class="headerlink" title="1、接口迁移"></a>1、接口迁移</h3><p>把之前的 spring boot 逻辑迁移到 MEPER 服务，新开放 http 接口处理打包业务。</p><h3 id="2、处理-App-导出数据包存储的逻辑"><a href="#2、处理-App-导出数据包存储的逻辑" class="headerlink" title="2、处理 App 导出数据包存储的逻辑"></a>2、处理 App 导出数据包存储的逻辑</h3><p>之前的打包文件的 package 逻辑对应的文件路径重新整理逻辑。</p><h3 id="3、初始化项目接口获取-App-数据包"><a href="#3、初始化项目接口获取-App-数据包" class="headerlink" title="3、初始化项目接口获取 App 数据包"></a>3、初始化项目接口获取 App 数据包</h3><p>优化创建 project 的逻辑，根据 Appid 获取对应 jbf 数据包，优化数据备份接口，还有项目初始化过程中的数据初始化 Task，兼容新的.MEPERApp (gzip,zip)文件。</p><h3 id="4、portal-的-fegin接口整理"><a href="#4、portal-的-fegin接口整理" class="headerlink" title="4、portal 的 fegin接口整理"></a>4、portal 的 fegin接口整理</h3><p>处理portal 的 fegin 接口，对应请求打包文件相关的接口独立区分开。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端页面任务</title>
      <link href="/2023/07/22/Vue%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BB%BB%E5%8A%A1/"/>
      <url>/2023/07/22/Vue%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>需要专业前端帮忙一下。</p><span id="more"></span><h2 id="Home主页调整"><a href="#Home主页调整" class="headerlink" title="Home主页调整"></a>Home主页调整</h2><p>静态页面的调整 </p><p>Home 主页样式调整还有两个小功能地方调整。</p><a href="/2023/07/10/%E9%97%A8%E6%88%B7%E7%BD%91%E7%AB%99%E5%8E%9F%E5%9E%8B/" title="门户网站原型">门户网站原型</a><h2 id="新页面"><a href="#新页面" class="headerlink" title="新页面"></a>新页面</h2><p><a href="https://mastergo.com/file/93555839967741?page_id=387:0411">MASTER Go原型设计页面</a></p><h3 id="1、产品介绍的WMS"><a href="#1、产品介绍的WMS" class="headerlink" title="1、产品介绍的WMS"></a>1、产品介绍的WMS</h3><p><img src="/images/pasted-18.png" alt="upload successful"><br> （图 1-2）</p><h3 id="2、产品下载"><a href="#2、产品下载" class="headerlink" title="2、产品下载"></a>2、产品下载</h3><p>分页组件不要了， 写一下 Table 样式和介绍</p><h3 id="3、应用详情页面"><a href="#3、应用详情页面" class="headerlink" title="3、应用详情页面"></a>3、应用详情页面</h3><p><img src="/images/pasted-19.png" alt="upload successful"><br>图 3</p><h3 id="4、产品介绍的-MES"><a href="#4、产品介绍的-MES" class="headerlink" title="4、产品介绍的 MES"></a>4、产品介绍的 MES</h3><p><img src="/images/pasted-20.png" alt="upload successful"><br>图 4</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>license试用接口</title>
      <link href="/2023/07/18/license%E8%AF%95%E7%94%A8%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/07/18/license%E8%AF%95%E7%94%A8%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>license 设计，目前是 App 下载完成后进行 License 申请， 然后在服务使用期间进行 license 校验，首先完成试用逻辑的 license 生成设计。</p><span id="more"></span><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>当前工作空间项目打包产生 App 下载使用时，需要对应的 license，可以在下载 App 时，把当前 App 对应的 exe 和试用的 license 文件打包成一个 Zip 压缩包，压缩包中还可以提供一些说明信息，当前 exe 运行安装方式，并且在安装过程中选择试用的 license 文件等信息的文件，类似如下效果：</p><blockquote><p>Meper-App.zip<br>– MeperApp.exe<br>– MeperTrialLicense.identity<br>– Readme.md</p></blockquote><p>所以需要MeperTrialLicense.identity试用许可证去验证当前 App 的试用时间。</p><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>license server 需要开放接口可以针对AppId 进行试用许可证的申请， 针对 MEPER-Cloud 的逻辑，下载 App 需要对应的 SI 账号并且是进行了企业认证的。所以在下载 App 的时候，MEPER 或者 portal 是可以获取到当前的用户信息还有对应下载的 App 信息。</p><p>所以在用户请求下载的时候，我们返回的文件流可以是系统动态产生的压缩文件流，MeperTrialLicense.identity可以在请求的过程中产生， license server 需要开放一个接口，接口可以接受 AppId 和 SI 的 UserId 去产生对应的试用许可证文件。</p><h2 id="需求设计"><a href="#需求设计" class="headerlink" title="需求设计"></a>需求设计</h2><h3 id="Portal-server"><a href="#Portal-server" class="headerlink" title="Portal server"></a>Portal server</h3><p>用户如果从 Vue 前端页面请求的话，是先请求到 Portal Server，Portal Server 直接转发请求到 Meper-Cloud 中进行压缩文件流的返回，同时可以在 Portal Server 中做一次权限验证。</p><h3 id="Meper-Cloud"><a href="#Meper-Cloud" class="headerlink" title="Meper-Cloud"></a>Meper-Cloud</h3><p>MEPER 服务做 App 下载请求的收口操作，当 Project 进行打包 App 时，MEPER 会导出当前 Project 的数据做成 App 数据包，然后请求 Inno Setup的server去打包对应 App 的 exe 文件。</p><p>当收到App 下载请求时MEPER 会先拿到当前 App 对应的exe 文件，然后在通过接口请求拿到 AppId 和 User信息，用 Appid 和 User 信息到 license server 去申请试用许可证的文件（MeperTrialLicense.identity），将试用许可证文件和 exe 文件打包 zip 压缩返回用户下载。</p><h3 id="license-server"><a href="#license-server" class="headerlink" title="license server"></a>license server</h3><p>license server 则需要开放接口，产生对应的试用许可证，并且支持对应试用许可证的校验逻辑。</p><h4 id="创建试用许可证接口"><a href="#创建试用许可证接口" class="headerlink" title="创建试用许可证接口"></a>创建试用许可证接口</h4><h5 id="MeperTrialLicense-identity文件的产生接口。"><a href="#MeperTrialLicense-identity文件的产生接口。" class="headerlink" title="MeperTrialLicense.identity文件的产生接口。"></a>MeperTrialLicense.identity文件的产生接口。</h5><p><strong>接口请求参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Request</span><br><span class="line">&#123;</span><br><span class="line">    &quot;AppId&quot;:&quot;1000011&quot;，    // 下载试用的 App</span><br><span class="line">    &quot;UserId&quot;:&quot;10001021&quot;，  // 在 MEPER 中认证的 SI 用户 ID</span><br><span class="line">    &quot;LoginName&quot;:&quot;Ryan&quot;,    // SI 登录名</span><br><span class="line">    &quot;FullName&quot;:&quot;杨正武&quot;,    // SI 注册全名</span><br><span class="line">    &quot;CompanyId&quot;:&quot;1010210&quot;, // SI 认证企业 Id</span><br><span class="line">    &quot;CompanyName&quot;:&quot;苏州华冠&quot; // SI 认证企业名称</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>返回对应的试用许可证文件</strong></p><h5 id="MeperTrialLicense-identity验证接口"><a href="#MeperTrialLicense-identity验证接口" class="headerlink" title="MeperTrialLicense.identity验证接口"></a>MeperTrialLicense.identity验证接口</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Request</span><br><span class="line">&#123;</span><br><span class="line">    &quot;AppId&quot;:&quot;1010101&quot;,    // AppId</span><br><span class="line">    &quot;File&quot;:&quot;*.identity&quot;,  // 二进制试用许可证</span><br><span class="line">    &quot;MAC&quot;:&quot;s12-s12-d-a9s&quot; // 运行机器的 MAC 地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当license server 第一次收到当前试用许可证的验证请求时，记录当前请求的 MAC 地址，然后校验许可证文件的有效性和对应 AppId 的一致性，并开始试用时间。</p><p><strong>第一次请求时接口需要处理的逻辑</strong></p><blockquote><p>1、验证许可证有效性<br>2、验证许可证和 AppId 是否对应<br>3、记录首次请求的 MAC 地址<br>4、开始试用时间</p></blockquote><p><strong>后续请求的逻辑</strong></p><blockquote><p>1、验证许可证有效性<br>2、AppId 验证<br>3、MAC 地址验证<br>4、时间验证</p></blockquote><h5 id="开放查询identity验证接口"><a href="#开放查询identity验证接口" class="headerlink" title="开放查询identity验证接口"></a>开放查询identity验证接口</h5><p>license server 开放查询接口，可以根据 UserId 或者 CompanyId 进行查询当前用户或者企业的试用许可证，插叙对应许可证对应的 App 和剩余试用时间等信息。</p><p>用户可以通过试用的许可证找到对应的 App 进行后续许可证的申请。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows 环境变量</title>
      <link href="/2023/07/17/windows-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2023/07/17/windows-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>windows 环境变量修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">立即生效环境变量：</span><br><span class="line">1、打开cmd输入： set PATH=C: </span><br><span class="line">2、关闭cmd </span><br><span class="line">3、重新打开cmd输入： echo %PATH%</span><br></pre></td></tr></table></figure><span id="more"></span><p>组要针对的问题是 MEPER 项目 node14</p><p>Vue的 website 项目是 node16所以打包的时候需要换 node 环境</p><p>npm 源镜像修改</p><blockquote><p>npm config get registry</p></blockquote><p>默认是指向 </p><blockquote><p><a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a>  也就是官方源。</p></blockquote><p>修改成淘宝源</p><blockquote><p>npm config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com/</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>门户网站原型</title>
      <link href="/2023/07/10/%E9%97%A8%E6%88%B7%E7%BD%91%E7%AB%99%E5%8E%9F%E5%9E%8B/"/>
      <url>/2023/07/10/%E9%97%A8%E6%88%B7%E7%BD%91%E7%AB%99%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>记录一下原型设计问题</p><span id="more"></span><h2 id="登录后-Header-的变化"><a href="#登录后-Header-的变化" class="headerlink" title="登录后 Header 的变化"></a>登录后 Header 的变化</h2><p><img src="/images/pasted-16.png" alt="upload successful"></p><h2 id="首页动画效果"><a href="#首页动画效果" class="headerlink" title="首页动画效果"></a>首页动画效果</h2><p>鼠标悬停 Hover 的时候会有一个透明度变化和放大的效果</p><p><img src="/images/pasted-17.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>幕客确定</title>
      <link href="/2023/07/04/%E5%B9%95%E5%AE%A2%E7%A1%AE%E5%AE%9A/"/>
      <url>/2023/07/04/%E5%B9%95%E5%AE%A2%E7%A1%AE%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>设计原型中需要确认的点</p><span id="more"></span><h2 id="应用详情"><a href="#应用详情" class="headerlink" title="应用详情"></a>应用详情</h2><p><img src="/images/pasted-11.png" alt="upload successful"></p><blockquote><p>图 1</p></blockquote><p><img src="/images/pasted-12.png" alt="upload successful"></p><blockquote><p>图 2</p></blockquote><p>现在应用市场中有两个应用详情，会有点疑惑，从设计上看，应该是以图 2 为准，然后把图1 中的评价反馈列表设计到图 2 中，这一点需要确认一下。</p><h3 id="确认结果"><a href="#确认结果" class="headerlink" title="确认结果"></a>确认结果</h3><p>以图 2 为原型处理。评价的先设计暂时先不做。</p><h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p><img src="/images/pasted-13.png" alt="upload successful"></p><p>首页的应用案例，目前从目录看对应的是应用案例，目前应用案例看应该是图中箭头指出的MES<br>、WMS、组件介绍三个页面，后面的草稿是否还有需要添加的内容需要确认。</p><h3 id="确认结果-1"><a href="#确认结果-1" class="headerlink" title="确认结果"></a>确认结果</h3><p>MES、WMS 这两个先做 就是针对这两个套件的介绍页面<br>先以MES草稿1 和 WMS草稿1为原型设计润色，如果需要丰富文案的话，Don 再继续提供。</p><h2 id="Header-平台菜单"><a href="#Header-平台菜单" class="headerlink" title="Header 平台菜单"></a>Header 平台菜单</h2><p><img src="/images/pasted-14.png" alt="upload successful"></p><p>首页的 Header 上面有一个平台的二级菜单，这个菜单对应的应该是哪个页面需要确认一下。</p><h3 id="确认结果-2"><a href="#确认结果-2" class="headerlink" title="确认结果"></a>确认结果</h3><p>MES、WMS 原始设计是针对套件的不同版本 暂时先不做。</p><h2 id="AGS-管理后台"><a href="#AGS-管理后台" class="headerlink" title="AGS 管理后台"></a>AGS 管理后台</h2><p><img src="/images/pasted-15.png" alt="upload successful"></p><p>设计反馈，AGS 管理后台从图中设计看是我们的管理员后台，这个当时在合同中是没有的这部分，我们这边可以参考 SI 管理后台进行页面处理，这个是否需要设计重新做。</p><h3 id="确认结果-3"><a href="#确认结果-3" class="headerlink" title="确认结果"></a>确认结果</h3><p>先设计 SI 管理后台，AGS 暂不处理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java IO</title>
      <link href="/2023/04/11/Java-IO/"/>
      <url>/2023/04/11/Java-IO/</url>
      
        <content type="html"><![CDATA[<p>在Java中，IO操作是非常常见的操作。</p><span id="more"></span><details>  <summary>展开查看</summary>  <pre>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Hello&quot;);</span><br></pre></td></tr></table></figure><p>  </pre></p></details><p>下面是Java IO相关需要关注的内容：</p><ul><li><p><strong>输入流和输出流：</strong>Java中的IO操作基本上是围绕着输入流和输出流进行的。输入流用于读取数据，输出流用于写入数据。</p></li><li><p><strong>字节流和字符流：</strong>Java IO提供了两种流，即字节流和字符流。字节流适用于处理二进制数据，字符流适用于处理文本数据。</p></li><li><p><strong>缓冲流：</strong>缓冲流是一种高效的流，它可以在读写数据时将数据缓存起来，从而减少对底层IO设备的访问次数，提高IO性能。</p></li><li><p><strong>文件操作：</strong>Java IO提供了大量的文件操作API，包括文件的读写、复制、移动、删除等。</p></li><li><p><strong>序列化和反序列化：</strong>序列化是将对象转换成字节流的过程，反序列化是将字节流转换成对象的过程。Java IO提供了ObjectInputStream和ObjectOutputStream两个类来支持对象的序列化和反序列化。</p></li><li><p><strong>网络编程：</strong>Java IO提供了一套强大的网络编程API，包括Socket、ServerSocket、DatagramSocket等类，可以实现基于TCP和UDP协议的网络编程。</p></li><li><p><strong>NIO：</strong>NIO是Java 1.4引入的新IO框架，它提供了非阻塞的IO操作，可以大幅度提高IO性能。NIO包含了Channel、Selector、Buffer等核心类。</p></li><li><p><strong>异步IO：</strong>Java 7引入了异步IO API，也称为NIO.2，它可以让应用程序在进行IO操作时不必阻塞，提高IO性能。</p></li></ul><p>总之，Java IO是Java编程中非常重要的一个方面，需要掌握输入流和输出流、字节流和字符流、缓冲流、文件操作、序列化和反序列化、网络编程、NIO等知识点，以提高IO性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2023/04/11/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/04/11/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>以下是Git常用操作的命令文档：</p><span id="more"></span><p>初始化仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>添加文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [file]</span><br></pre></td></tr></table></figure><p>提交代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;commit message&quot;</span><br></pre></td></tr></table></figure><p>查看状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>查看历史记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>分支管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch [branch_name] # 创建分支</span><br><span class="line">git checkout [branch_name] # 切换分支</span><br><span class="line">git merge [branch_name] # 合并分支</span><br><span class="line">git branch -d [branch_name] # 删除分支</span><br></pre></td></tr></table></figure><p>撤销操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset [commit_id] # 撤销本地仓库的提交操作</span><br><span class="line">git revert [commit_id] # 撤销远程仓库的提交操作</span><br></pre></td></tr></table></figure><p>远程仓库操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote -v # 查看远程仓库信息</span><br><span class="line">git clone [remote_repository_url] # 克隆远程仓库到本地</span><br><span class="line">git push [remote_repository_name] [branch_name] # 推送代码到远程仓库</span><br><span class="line">git pull [remote_repository_name] [branch_name] # 拉取远程仓库代码到本地</span><br></pre></td></tr></table></figure><p>标签管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag # 查看标签信息</span><br><span class="line">git tag -a [tag_name] -m &quot;tag message&quot; # 创建标签</span><br><span class="line">git push [remote_repository_name] --tags # 推送标签到远程仓库</span><br></pre></td></tr></table></figure><p>忽略文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 创建.gitignore文件，添加需要忽略的文件或目录</span><br><span class="line">touch .gitignore</span><br><span class="line">echo &quot;node_modules/&quot; &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure><p>以上是Git常用操作的命令文档，可以帮助开发者更好地使用Git进行代码管理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库SQL优化</title>
      <link href="/2023/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2023/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>SQL优化是数据库性能优化中的重要环节，常见的SQL优化包括以下几种：</p><span id="more"></span><ul><li><p><strong>索引优化：</strong>索引是提高数据库查询性能的关键。通过为经常查询的列创建索引，可以大幅度减少数据库查询时间。</p></li><li><p><strong>SQL重构：</strong>对复杂的SQL语句进行重构，将其分解为多个简单的语句，并使用连接查询、子查询等技术来优化查询性能。</p></li><li><p><strong>避免全表扫描：</strong>全表扫描是查询性能最差的操作之一。可以通过合理使用索引、使用limit等方法避免全表扫描。</p></li><li><p><strong>优化join操作：</strong>join是数据库查询中常用的操作，但在大数据量的情况下，join操作的性能往往较低。可以通过尽可能减少join操作、合理使用索引、使用临时表等方法来优化join操作性能。</p></li><li><p><strong>避免大事务：</strong>大事务会占用数据库资源，并可能导致死锁等问题。可以通过拆分大事务、使用批量操作等方法来避免大事务。</p></li><li><p><strong>优化数据类型：</strong>选择合适的数据类型可以提高查询性能。对于经常查询的列，应选择尽可能小的数据类型，以减少查询时间。</p></li><li><p><strong>合理使用缓存：</strong>对于经常访问的数据，可以使用缓存来减少数据库访问次数，从而提高查询性能。</p></li></ul><p>总之，SQL优化是数据库性能优化中的重要环节，通过合理使用索引、优化查询语句、减少全表扫描等方法，可以大幅度提高数据库查询性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DB </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级Java软件工程师</title>
      <link href="/2023/04/11/%E9%AB%98%E7%BA%A7Java%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
      <url>/2023/04/11/%E9%AB%98%E7%BA%A7Java%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<p>作为一名高级Java工程师，您需要具备以下技术能力：</p><span id="more"></span><ul><li><p><strong>Java语言基础：</strong>熟练掌握Java核心概念、语法、关键字、集合框架、多线程、IO等。</p></li><li><p><strong>JavaWeb开发：</strong>熟悉JavaWeb开发，包括Servlet、JSP、SpringMVC等框架，了解RESTful API设计规范和实践。</p></li><li><p><strong>数据库技术：</strong>熟悉数据库设计、SQL语言以及常见数据库的使用和优化，例如MySQL、Oracle等。</p></li><li><p><strong>分布式技术：</strong>熟悉分布式架构、微服务架构设计和实现，了解SpringCloud、Dubbo、Zookeeper等常用的分布式框架。</p></li><li><p><strong>高并发和高可用：</strong>熟悉常见的高并发场景，能够设计和实现高可用的分布式系统。</p></li><li><p><strong>消息队列：</strong>熟悉消息队列的基本原理和使用，如Kafka、RabbitMQ等。</p></li><li><p><strong>缓存技术：</strong>了解缓存的基本原理，熟练使用常见的缓存技术，如Redis、Memcached等。</p></li><li><p><strong>DevOps：</strong>熟悉持续集成、持续交付、自动化部署等DevOps技术，了解Docker、Kubernetes等容器化技术。</p></li><li><p><strong>代码质量和测试：</strong>熟悉代码质量管理和测试流程，能够使用常见的测试框架和工具，如JUnit、Mockito、Selenium等。</p></li><li><p><strong>面向对象设计和设计模式：</strong>熟练掌握面向对象的设计思想和设计模式，能够进行系统设计和重构。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis的一些内容</title>
      <link href="/2023/04/04/Redis%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9/"/>
      <url>/2023/04/04/Redis%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis集群的实现方案"><a href="#Redis集群的实现方案" class="headerlink" title="Redis集群的实现方案"></a>Redis集群的实现方案</h2><p>Redis是一种单线程、内存存储、高性能的NoSQL数据库，它的数据存储在内存中，因此它能够提供非常快速的读写速度。然而，单机Redis在处理大量数据时，可能会遇到内存不足、网络带宽瓶颈等问题，这时就需要使用Redis集群来解决这些问题。Redis集群的实现方案有以下几种：</p><span id="more"></span><h3 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h3><p>主从复制是最简单的Redis集群方案，它将数据分布在多台Redis服务器上，并通过主节点将数据同步到从节点，从节点只能读取数据，不能写入数据。主从复制方案可以提高Redis的可靠性和可扩展性。</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵模式是一种自动故障转移方案，它使用一组哨兵节点来监控主节点和从节点的状态，当主节点出现故障时，哨兵节点会自动将其中一个从节点提升为主节点，从而实现高可用性。</p><h3 id="Redis-Cluster模式"><a href="#Redis-Cluster模式" class="headerlink" title="Redis Cluster模式"></a>Redis Cluster模式</h3><p>Redis Cluster模式是一种分布式集群方案，它将数据分散在多个节点上，并使用哈希槽来管理数据的分配。Redis Cluster模式可以提高Redis的可扩展性和可用性，同时也支持自动故障转移。</p><h3 id="Codis模式"><a href="#Codis模式" class="headerlink" title="Codis模式"></a>Codis模式</h3><p>Codis是一个分布式Redis解决方案，它使用代理模式来实现分片和负载均衡。Codis将数据分片到多个Redis节点上，并使用Codis Proxy来处理读写请求，从而实现高可用性和高性能。</p><p>总之，Redis集群的实现方案有多种选择，主从复制、哨兵模式、Redis Cluster模式和Codis模式等都可以提高Redis的可靠性、可扩展性和性能。选择哪种方案，需要根据实际业务需求和数据规模来决定。</p><h2 id="Redis-cluster"><a href="#Redis-cluster" class="headerlink" title="Redis cluster"></a>Redis cluster</h2><p>Redis Cluster是Redis的一种分布式集群方案，它将数据分散在多个节点上，提高了Redis的可扩展性和可用性。Redis Cluster使用哈希槽来管理数据的分配，将所有的数据分为16384个哈希槽，每个节点负责处理其中一部分哈希槽，这样就能够实现分布式存储和负载均衡。</p><h3 id="Redis-Cluster的特点有"><a href="#Redis-Cluster的特点有" class="headerlink" title="Redis Cluster的特点有"></a>Redis Cluster的特点有</h3><ul><li><p><strong>高可用性：Redis Cluster支持自动故障转移，当一个节点出现故障时，集群中的其他节点会自动接管该节点的哈希槽，从而保证数据的可用性。</strong></p></li><li><p><strong>高可扩展性：Redis Cluster的每个节点都可以处理一部分哈希槽，当需要扩容时，只需要添加新的节点，然后将一部分哈希槽分配给新节点即可，不需要对整个集群进行重新分片。</strong></p></li><li><p><strong>分布式存储：Redis Cluster将数据分散在多个节点上，每个节点都有一部分数据，这样就可以减少单个节点的内存压力，提高集群的性能和可靠性。</strong></p></li><li><p><strong>数据一致性：Redis Cluster使用Gossip协议来实现数据一致性，每个节点都会将自己的状态信息广播给其他节点，从而实现数据同步和一致性。</strong></p></li></ul><h3 id="Redis-Cluster的使用需要注意以下几点"><a href="#Redis-Cluster的使用需要注意以下几点" class="headerlink" title="Redis Cluster的使用需要注意以下几点"></a>Redis Cluster的使用需要注意以下几点</h3><ul><li><p><strong>Redis Cluster需要至少3个节点才能正常工作，建议使用奇数个节点，这样可以减少分裂的可能性。</strong></p></li><li><p><strong>Redis Cluster需要使用Redis 3.0以上版本才支持。</strong></p></li><li><p><strong>Redis Cluster不支持跨节点事务，只支持节点内的事务。</strong></p></li><li><p><strong>Redis Cluster的性能受限于网络带宽和延迟，需要在配置网络和硬件环境时进行优化。</strong></p></li></ul><p>总之，Redis Cluster是Redis的一种分布式集群方案，它能够提高Redis的可扩展性和可用性，实现高性能的数据存储和处理。但是，在使用Redis Cluster时需要注意其使用限制和优化问题。</p><h2 id="Redis缓存指标"><a href="#Redis缓存指标" class="headerlink" title="Redis缓存指标"></a>Redis缓存指标</h2><p>以下是一些好的Redis缓存指标：</p><ul><li><p><strong>命中率（Hit rate）：</strong>这是指从Redis缓存中读取的数据量与请求总量的比率。较高的命中率通常表示Redis缓存配置和使用得当，能够有效减少对后端存储的访问。</p></li><li><p><strong>平均响应时间（Average response time）：</strong>这是指Redis缓存对请求的平均响应时间。较短的平均响应时间通常意味着Redis服务器响应速度快，缓存数据存取效率高。</p></li><li><p><strong>QPS（Queries Per Second）：</strong>这是指Redis服务器每秒处理的请求次数。较高的QPS通常表示Redis服务器的处理能力强，可以支持更高的并发访问。</p></li><li><p><strong>内存占用（Memory usage）：</strong>这是指Redis服务器当前使用的内存总量。较低的内存占用通常意味着Redis缓存的使用效率高，可以有效减少内存使用。</p></li><li><p><strong>缓存命中时间（Cache hit time）：</strong>这是指Redis缓存数据的保存时间，通常可以通过配置缓存项的过期时间来设置。较长的缓存命中时间可以有效提高缓存命中率，减少对后端存储的访问。</p></li><li><p><strong>缓存失效率（Cache invalidation rate）：</strong>这是指Redis缓存中缓存项失效的频率。较低的失效率通常意味着Redis缓存数据的稳定性高，可以保证缓存数据的可靠性和一致性。</p></li></ul><p>综上所述，好的Redis缓存指标应该包括命中率、平均响应时间、QPS、内存占用、缓存命中时间和缓存失效率等方面，这些指标可以帮助我们了解Redis缓存的性能和稳定性，从而进行优化和调整。</p><h2 id="Redis在使用中"><a href="#Redis在使用中" class="headerlink" title="Redis在使用中"></a>Redis在使用中</h2><h3 id="Redis-Bucket"><a href="#Redis-Bucket" class="headerlink" title="Redis Bucket"></a>Redis Bucket</h3><p>使用Redisson提供的Redis Bucket对象可以带来以下好处：</p><ul><li><p><strong>简化代码：</strong>使用Redis Bucket对象可以方便地进行常见的Redis操作，如存储和获取数据，而不需要手动编写Redis命令，从而简化了代码。</p></li><li><p><strong>提高安全性：</strong>Redis Bucket对象提供了数据类型转换和序列化等功能，可以确保存储和获取的数据类型正确，并且可以对存储的数据进行序列化和反序列化，从而提高了数据的安全性。</p></li><li><p><strong>增加可扩展性：</strong>使用Redis Bucket对象可以很容易地切换到其他类型的Redis服务器，如Redis Sentinel、Redis Cluster等，从而增加了应用的可扩展性。</p></li><li><p><strong>支持分布式：</strong>Redis Bucket对象可以用于在分布式环境下进行数据的存储和获取，从而支持多节点的Redis集群环境。</p></li></ul><p>综上所述，使用Redis Bucket对象可以方便地进行Redis操作，同时提高了数据的安全性和可扩展性，是一个更加便捷和高效的操作方式。</p><h3 id="RBucket实现"><a href="#RBucket实现" class="headerlink" title="RBucket实现"></a>RBucket实现</h3><p>Redisson中的RBucket实现是通过将Java对象序列化成二进制数据后，再存储到Redis中的一个String类型的数据结构上实现的。</p><p>具体来说，Redisson中的RBucket对象实现了Redisson的RObject接口，该接口定义了一些Redis操作的通用方法，如get、set、delete等方法。RBucket对象在set方法中会将Java对象序列化为二进制数据，然后通过Redis的SET命令将这个二进制数据存储到Redis中的一个String类型的数据结构上。</p><p>在get方法中，RBucket对象会从Redis中读取这个String类型的数据，并将其反序列化为Java对象，然后返回给调用方。如果读取到的是一个不存在的Key，get方法会返回null。</p><p>因此，Redisson中的RBucket对象是通过将Java对象序列化后存储到Redis中，再通过反序列化获取Java对象来实现的。它提供了一种简单方便的操作Redis数据的方式，同时支持多种Java对象类型，如String、List、Map等，并且支持多节点的Redis集群环境。</p><h2 id="针对Redis进行优化"><a href="#针对Redis进行优化" class="headerlink" title="针对Redis进行优化"></a>针对Redis进行优化</h2><p>以下是针对Redis进行优化的几个方面：</p><ul><li><p><strong>内存优化：</strong>Redis是一个基于内存的数据存储系统，内存使用对性能和可靠性至关重要。可以通过合理的配置参数，如maxmemory、maxmemory-policy等，来控制Redis的内存使用，避免内存溢出和性能问题。</p></li><li><p><strong>持久化优化：</strong>Redis提供了RDB和AOF两种持久化方式，可以选择合适的持久化方式来保证数据的可靠性和恢复性。同时，可以通过调整参数，如save、appendonly、fsync等，来优化持久化的性能和可靠性。</p></li><li><p><strong>网络优化：</strong>Redis是一个网络服务，网络性能对Redis的性能和可靠性影响很大。可以通过优化网络配置、调整连接池、使用高性能网络协议等方式，来提高Redis的网络性能和可靠性。</p></li><li><p><strong>代码优化：</strong>Redis的性能和可靠性还受到代码质量和算法的影响。可以通过优化代码结构、使用高效的算法、合理的数据结构等方式，来提高Redis的性能和可靠性。</p></li><li><p><strong>集群优化：</strong>Redis的集群模式可以提高性能和可靠性，但也需要注意优化集群的配置和管理。可以通过合理的分片、节点调度、监控和告警等方式，来优化Redis集群的性能和可靠性。</p></li></ul><p>总之，针对Redis的优化需要从多个方面进行，综合考虑系统的性能、可靠性、可扩展性等因素，选择合适的优化策略和方法，以提高Redis的性能和可靠性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存相关的东西</title>
      <link href="/2023/04/04/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
      <url>/2023/04/04/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<p>记录一下MemberCache和Redis的缓存相关的东西</p><span id="more"></span><h2 id="MemberCache和Redis"><a href="#MemberCache和Redis" class="headerlink" title="MemberCache和Redis"></a>MemberCache和Redis</h2><p>MemberCache和Redis都是常用的分布式缓存工具，它们之间的区别主要体现在以下几个方面：</p><ul><li><p><strong>数据分片算法</strong><br>MemberCache使用一致性哈希算法进行数据分片，而Redis使用的是Modulo算法。一致性哈希算法在节点的动态增加和删除时具有更好的性能和稳定性，可以避免因为节点数量变化导致的数据迁移问题。</p></li><li><p><strong>数据结构和支持</strong><br>Redis支持的数据结构比MemberCache更多，包括字符串、哈希表、列表、集合、有序集合、地理空间等。此外，Redis还提供了丰富的数据操作和扩展功能，如发布&#x2F;订阅、Lua脚本、事务、管道、持久化等。</p></li><li><p><strong>内存管理</strong><br>MemberCache采用的是Slab分配算法，可以更有效地利用内存，而Redis则采用的是内存分页机制。这两种算法在内存管理上各有优缺点，需要根据实际场景来选择。</p></li><li><p><strong>监控管理</strong><br>MemberCache提供了Web界面和命令行工具来进行监控和管理，而Redis则提供了redis-cli命令行工具和redis-stat监控工具，但相比MemberCache来说功能相对简单。</p></li><li><p><strong>语言支持</strong><br>MemberCache的客户端库支持多种编程语言，包括Java、C++、Python、Ruby、Go等。Redis则支持更多的编程语言，如C、C++、Java、Python、Ruby、Go、Node.js等。</p></li></ul><p>总之，MemberCache和Redis都是成熟的分布式缓存工具，具有各自的优缺点，需要根据实际业务需求来选择。</p><h2 id="MemberCache"><a href="#MemberCache" class="headerlink" title="MemberCache"></a>MemberCache</h2><p>MemberCache是一个开源的分布式缓存工具，用于存储和管理缓存数据。它的实现原理如下：</p><ul><li><p><strong>基于哈希表的分片存储</strong><br>MemberCache将缓存数据按照key的hash值进行分片存储在多个节点上，使用一致性哈希算法来实现节点的动态增加和删除。这样可以提高缓存的并发处理能力和可扩展性，同时避免单点故障的问题。</p></li><li><p><strong>副本备份</strong><br>MemberCache支持在多个节点上存储数据的副本，以提高数据的可用性和容错能力。可以通过配置参数来设置副本的个数，可以是单个节点，也可以是多个节点。</p></li><li><p><strong>容错恢复</strong><br>MemberCache支持节点的自动容错和恢复，当某个节点失效时，会自动将该节点上的缓存数据迁移到其他节点上，并将数据的副本备份到其他节点上，以保证数据的完整性和可用性。</p></li><li><p><strong>数据一致性</strong><br>MemberCache使用分布式锁和事务机制来保证数据的一致性，避免因为多个节点并发访问导致的数据不一致问题。同时，MemberCache支持多种数据结构的操作，如字符串、哈希表、列表、集合、有序集合等，可以满足不同业务场景的需求。</p></li><li><p><strong>监控管理</strong><br>MemberCache提供了丰富的监控和管理功能，可以通过Web界面或命令行工具来查看节点状态、缓存数据、性能指标等信息，也可以进行节点扩容、缩容、数据迁移等操作，方便用户进行缓存的管理和维护。</p></li></ul><p>总之，MemberCache通过分片存储、副本备份、容错恢复、数据一致性和监控管理等多种机制，实现了一个高性能、可靠、可扩展的分布式缓存工具。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一种高性能的开源内存数据存储系统，它支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等。Redis的实现原理可以概括为以下几点：</p><ul><li><p><strong>基于内存：</strong>Redis将所有数据存储在内存中，因此它能够提供非常快速的读写速度。</p></li><li><p><strong>持久化：</strong>Redis支持两种持久化方式，一种是快照方式，将整个数据集快照到磁盘上，另一种是日志方式，将所有写操作追加到文件末尾。</p></li><li><p><strong>单线程：</strong>Redis是单线程模型的，所有的读写请求都是由一个线程来处理的，这样可以避免线程切换带来的开销，并且简化了代码实现。</p></li><li><p><strong>非阻塞I&#x2F;O：</strong>Redis使用非阻塞I&#x2F;O模型，它的网络模块采用epoll模型，可以支持高并发的读写请求。</p></li><li><p><strong>多种数据结构：</strong>Redis支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等，每种数据结构都有自己的操作命令。</p></li><li><p><strong>事件驱动：</strong>Redis使用事件驱动模型，将所有的网络请求都转换成事件，并通过事件循环来处理这些事件。</p></li></ul><p>总之，Redis的实现原理是基于内存、持久化、单线程、非阻塞I&#x2F;O、多种数据结构和事件驱动等技术，通过这些技术的结合，Redis能够提供高性能、高可靠性和高可扩展性的数据存储服务。</p><h2 id="Caffeine-Cache"><a href="#Caffeine-Cache" class="headerlink" title="Caffeine Cache"></a>Caffeine Cache</h2><p>Caffeine Cache是一种基于Java的本地缓存工具，它的实现原理如下：</p><ul><li><p><strong>基于LinkedHashMap的存储</strong><br>Caffeine Cache使用LinkedHashMap来存储缓存数据，它可以保证缓存数据的顺序和访问顺序一致，支持LRU（最近最少使用）和FIFO（先进先出）等淘汰策略。在LinkedHashMap中，每个缓存条目都有一个链表指针，用于连接上一个条目和下一个条目，这样可以快速的实现LRU算法。</p></li><li><p><strong>基于ConcurrentHashMap的并发处理</strong><br>Caffeine Cache使用ConcurrentHashMap来支持多线程并发访问，保证线程安全。它采用分段锁机制，将整个Map分成多个段，每个段有一个锁，当多个线程访问不同的段时，可以并发执行，提高缓存的并发处理能力。</p></li><li><p><strong>数据加载和计算</strong><br>Caffeine Cache支持异步和同步的数据加载和计算。在缓存未命中的情况下，如果使用同步加载数据，则当前线程会被阻塞，直到数据加载完成；如果使用异步加载数据，则当前线程会立即返回一个Future对象，等到数据加载完成后再获取数据。此外，Caffeine Cache还提供了计算函数的功能，可以在缓存未命中时，使用计算函数来计算数据并缓存。</p></li><li><p><strong>数据过期策略</strong><br>Caffeine Cache支持多种数据过期策略，包括基于时间过期和基于大小过期。在基于时间过期的策略中，可以设置缓存数据的最大存活时间和最大闲置时间；在基于大小过期的策略中，可以设置缓存的最大数量和最大权重。当缓存数据过期或达到最大限制时，会触发淘汰策略，使用LRU或FIFO算法进行淘汰。</p></li><li><p><strong>监控管理</strong><br>Caffeine Cache提供了丰富的监控和管理功能，可以通过统计信息、日志、事件监听器等方式，来查看缓存的使用情况、性能指标等信息，也可以进行缓存的清空、移除、调整大小等操作，方便用户进行缓存的管理和维护。</p></li></ul><p>总之，Caffeine Cache通过LinkedHashMap、ConcurrentHashMap、分段锁、数据加载和计算、数据过期策略等多种机制，实现了一个高性能、高并发、灵活可控的本地缓存工具。</p><p>Caffeine Cache是一个基于内存的缓存库，其底层存储采用LinkedHashMap实现LRU算法，同时使用ConcurrentHashMap实现并发处理。</p><p>具体来说，Caffeine Cache内部使用了一个双向链表LinkedHashMap作为底层存储结构。LinkedHashMap中的节点包括key、value、前驱节点和后继节点，按照插入顺序或访问顺序来维护节点的顺序。当缓存满了之后，Caffeine Cache会根据LRU算法淘汰最近最少使用的节点，以便为新的节点腾出空间。</p><p>同时，Caffeine Cache也提供了线程安全的机制。当多个线程同时访问缓存时，Caffeine Cache会将缓存分成多个Segment，每个Segment都是一个独立的ConcurrentHashMap，拥有自己的锁。当多个线程访问不同的Segment时，可以并发执行，从而提高了并发处理能力。</p><p>综上所述，Caffeine Cache通过LinkedHashMap实现LRU算法，通过ConcurrentHashMap实现线程安全的并发处理，同时还提供了很多其他的高级特性，如自动加载、过期时间、缓存统计等。</p><h2 id="LinkedHashMap、ConcurrentHashMap"><a href="#LinkedHashMap、ConcurrentHashMap" class="headerlink" title="LinkedHashMap、ConcurrentHashMap"></a>LinkedHashMap、ConcurrentHashMap</h2><p>LinkedHashMap和ConcurrentHashMap都是Java集合框架中的Map实现，它们具有以下特点：</p><ul><li><strong>LinkedHashMap</strong><br>LinkedHashMap是HashMap的一个子类，它在HashMap的基础上增加了一个双向链表，用于维护插入顺序或访问顺序。具体来说，当构造LinkedHashMap时，可以指定访问顺序或插入顺序，当对LinkedHashMap进行遍历时，会按照指定的顺序来遍历。</li></ul><p>LinkedHashMap的主要优点是可以实现LRU（最近最少使用）缓存淘汰算法，同时也可以实现FIFO（先进先出）算法。缺点是线程不安全，不适合在高并发场景下使用。</p><ul><li><strong>ConcurrentHashMap</strong><br>ConcurrentHashMap是HashMap的线程安全版本，它使用了锁分段技术来实现并发控制。具体来说，ConcurrentHashMap将整个Map分成多个Segment段，每个Segment都是一个独立的HashMap，拥有自己的锁，当多个线程访问不同的Segment时，可以并发执行，从而提高了并发处理能力。</li></ul><p>ConcurrentHashMap的主要优点是线程安全，支持高并发操作，同时也提供了和HashMap类似的API接口。缺点是内存占用较大，因为需要维护多个Segment段，同时线程安全的实现也会带来一定的性能损失。</p><p>综上所述，LinkedHashMap适用于需要保证顺序的场景，可以用于实现LRU缓存淘汰算法；ConcurrentHashMap适用于高并发场景，可以保证线程安全。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
            <tag> MemberCache </tag>
            
            <tag> Cache </tag>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树的实现原理</title>
      <link href="/2023/04/04/B%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2023/04/04/B%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>B树是一种多路平衡查找树，主要用于实现在磁盘等外存储器上的数据结构，它通过多路分支、节点分裂与合并等方式来保证树的平衡性和快速的查找、插入、删除操作。</p><span id="more"></span><h2 id="B树的实现原理"><a href="#B树的实现原理" class="headerlink" title="B树的实现原理"></a>B树的实现原理</h2><p>如下：</p><ul><li><p><strong>B树的节点定义：</strong>B树节点一般包括关键字、指向子节点的指针、以及一些控制信息，例如父节点指针、节点类型等。</p></li><li><p><strong>节点的分裂：</strong>当一个节点中关键字的数量超过了B树节点规定的最大值时，需要将节点分裂为两个节点，并将中间的关键字向上层节点提升，以保持树的平衡性。</p></li><li><p><strong>节点的合并：</strong>当一个节点中关键字的数量低于B树节点规定的最小值时，需要将该节点与它的兄弟节点合并，并将合并后的关键字从上层节点删除，以保持树的平衡性。</p></li><li><p><strong>插入操作：</strong>B树的插入操作主要包括查找插入位置、插入关键字并保持节点平衡。具体操作流程是：从根节点开始，依次查找到叶子节点，如果叶子节点未满，则直接插入；否则，需要将叶子节点分裂并插入关键字，同时将中间的关键字插入父节点，并保持节点平衡。</p></li><li><p><strong>删除操作：</strong>B树的删除操作主要包括查找待删除节点、删除关键字并保持节点平衡。具体操作流程是：从根节点开始，依次查找到待删除节点，如果该节点是叶子节点，则直接删除；否则，需要找到该节点右子树的最小节点或左子树的最大节点来替换待删除节点，同时保持节点平衡。</p></li></ul><p>总的来说，B树的实现原理包括节点的定义、节点的分裂与合并、插入操作、删除操作等。B树通过多路分支、节点分裂与合并等方式来保证树的平衡性和快速的查找、插入、删除操作，适合于在磁盘等外存储器上的数据结构。</p><h2 id="B树有几种"><a href="#B树有几种" class="headerlink" title="B树有几种"></a>B树有几种</h2><p>在B树的概念中，一般说的是B树（B-tree），但是在实际使用中，我们可以根据实际需求来对B树进行改进，从而得到不同的B树类型。常见的B树类型有以下几种：</p><ul><li><p><strong>B树（B-tree）：</strong>最常见的B树类型，也是B树的基本形式。在B树中，每个节点可以包含多个子节点，从而提高数据访问效率。</p></li><li><p><strong>B+树（B+ tree）：</strong>在B+树中，所有的关键字都保存在叶子节点中，并且每个叶子节点通过指针链接起来，形成一个有序的链表。B+树的非叶子节点只用来索引，不保存数据，因此可以更快地进行查找。</p></li><li><p><strong>B树（B tree）：</strong>B树是B+树的一种变体，它通过减少节点的分裂和合并来提高B+树的性能。在B树中，每个节点至少填满了2&#x2F;3个子节点，从而减少了节点的分裂和合并操作。</p></li><li><p><strong>2-3树（2-3 tree）：</strong>2-3树也是一种多路查找树，它的每个节点可以有1个、2个或3个子节点。在2-3树中，所有的叶子节点都在同一层，从而可以保持树的平衡。</p></li></ul><p>总的来说，B树的类型有很多种，可以根据实际需求选择不同的B树类型。不同的B树类型在性能和适用场景上有所不同，需要根据具体情况进行选择。</p><h2 id="B树和二叉树"><a href="#B树和二叉树" class="headerlink" title="B树和二叉树"></a>B树和二叉树</h2><p>B树和二叉树是两种不同的数据结构，它们在结构上有很大的不同。以下是它们之间的区别：</p><ul><li><p><strong>节点数量不同：</strong>B树节点可以有多个子节点，而二叉树每个节点最多只有两个子节点。</p></li><li><p><strong>平衡性不同：</strong>B树是一种平衡的多叉树，可以有多个子节点，每个节点的子节点数量在一定范围内，使得树的高度更低，访问节点更快。而二叉树只有左右两个子节点，因此相对来说更难保持平衡。</p></li><li><p><strong>搜索方式不同：</strong>B树通常是用于大型数据存储，支持高效的随机查找、插入、删除操作，而二叉树通常是用于排序和查找操作，支持快速的顺序遍历。</p></li><li><p><strong>应用场景不同：</strong>B树适合存储海量数据，如数据库索引，文件系统等；而二叉树适合处理数据集合，如排序，查找等。</p></li></ul><p>总的来说，B树和二叉树在结构上有很大的不同，根据不同的应用场景选择不同的数据结构可以提高程序的性能和效率。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种自平衡的二叉搜索树，它是由一组节点和链接组成的有向无环图。红黑树的节点分为红色节点和黑色节点两种，它的性质如下：</p><ul><li><strong>每个节点要么是红色，要么是黑色。</strong></li><li><strong>根节点是黑色的。</strong></li><li><strong>每个叶子节点（空节点）都是黑色的。</strong></li><li><strong>如果一个节点是红色的，则它的子节点必须是黑色的。</strong></li><li><strong>从任意节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</strong></li></ul><p>红黑树的特点保证了其高度不会超过 2log(n+1)，其中 n 是红黑树中节点的个数。这意味着在插入和删除操作时，红黑树可以通过旋转和重新着色等操作来自动调整树的结构，以保持其自平衡的特性，从而保证了其高效的查找、插入和删除操作。</p><p>在实现红黑树时，我们需要定义一个节点类，用于存储节点的键值、左子节点和右子节点、颜色等信息。红黑树的基本操作包括左旋、右旋、颜色翻转和插入删除操作等。其中，左旋和右旋操作用于维护红黑树的平衡性，颜色翻转操作用于解决红黑树中出现的某些特殊情况，而插入删除操作则需要结合左旋、右旋和颜色翻转等操作来完成。</p><p>红黑树是一种重要的自平衡二叉搜索树，它通过旋转和重新着色等操作来保持树的平衡性，从而实现高效的查找、插入和删除操作。红黑树的性质和操作虽然比较复杂，但是其应用广泛，例如在C++ STL中的set和map等容器中就采用了红黑树作为底层数据结构。</p><h2 id="红黑节点"><a href="#红黑节点" class="headerlink" title="红黑节点"></a>红黑节点</h2><p>红黑树中每个节点都有一个颜色，通常是红色或黑色，这个颜色表示该节点在树中的位置和状态。</p><p>红色节点表示该节点是一个“临时节点”，即在插入或删除操作后，它是暂时存在于树中的节点，它可能在之后的旋转或重新着色操作中被删除或者被重新着色为黑色。</p><p>黑色节点则表示该节点是一个“稳定节点”，它在红黑树中是一个固定的节点，它不会在任何操作中被删除或着色为红色。</p><p>红黑树通过限制节点的颜色，来保证树的平衡性和高效性。根据红黑树的性质，每个节点不是红色就是黑色，同时满足如下性质：</p><ul><li>根节点是黑色的；</li><li>所有的叶节点都是黑色的空节点（即，不含数据的节点）；</li><li>如果一个节点是红色的，则它的两个子节点都是黑色的；</li><li>从任意一个节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li></ul><p>这些性质保证了红黑树的高效性和平衡性，保证了任意操作的时间复杂度是 O(log n) 级别的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 红黑树 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> B树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2023/04/04/MongoDB/"/>
      <url>/2023/04/04/MongoDB/</url>
      
        <content type="html"><![CDATA[<p>MongoDB适用于需要存储大量非结构化或半结构化数据，并需要高度可扩展性和高性能的场景。</p><span id="more"></span><p>例如：</p><ul><li><p><strong>Web应用：</strong>MongoDB适用于Web应用程序，例如博客、电子商务、社交网络等，这些应用通常需要处理大量半结构化数据，例如用户评论、商品信息、社交网络数据等。</p></li><li><p><strong>日志管理：</strong>MongoDB适用于存储和管理日志数据，例如Web服务器日志、系统日志、应用程序日志等。</p></li><li><p><strong>物联网(IoT)：</strong>MongoDB适用于物联网应用，例如智能家居、智能城市、智能工厂等，这些应用通常需要存储和管理大量设备数据，例如传感器数据、控制数据等。</p></li><li><p><strong>大数据：</strong>MongoDB适用于大数据场景，例如数据分析、数据挖掘、数据仓库等，这些应用通常需要高度可扩展性和高性能的数据存储和查询能力。</p></li><li><p><strong>游戏开发：</strong>MongoDB适用于游戏开发，例如在线游戏、游戏排行榜、用户数据存储等，这些应用通常需要存储和管理大量半结构化数据，并需要高度可扩展性和高性能。</p></li></ul><p>总之，MongoDB适用于需要高度可扩展性、高性能、半结构化或非结构化数据存储的场景。但需要注意的是，MongoDB不适合需要严格事务支持的场景，例如银行、金融等领域。</p><h3 id="MongoDB不适合需要严格事务支持的场景"><a href="#MongoDB不适合需要严格事务支持的场景" class="headerlink" title="MongoDB不适合需要严格事务支持的场景"></a>MongoDB不适合需要严格事务支持的场景</h3><p>MongoDB不适合需要严格事务支持的场景是因为它在事务支持方面的能力相对较弱，无法提供与传统关系型数据库相同的严格事务保证。MongoDB支持的事务被称为分布式事务，它只能保证事务内的操作原子性，而不能保证事务间的一致性。</p><p>具体来说，MongoDB在4.0版本之前，只支持针对单个文档的事务，无法在多个文档之间执行事务。在4.0版本中，MongoDB新增了分布式事务支持，可以在多个文档之间执行事务，但是仍然无法提供与传统关系型数据库相同的严格事务保证，例如ACID属性中的一致性。</p><p>因此，在需要严格事务保证的场景，例如银行、金融等领域，通常需要使用传统关系型数据库，例如MySQL、Oracle等。而在需要高度可扩展性、高性能、半结构化或非结构化数据存储的场景，则可以选择MongoDB等NoSQL数据库。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引原理</title>
      <link href="/2023/04/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
      <url>/2023/04/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>数据库索引是用于提高数据查询速度的一种数据结构，它本身是一种特殊的数据结构，可以帮助数据库快速的定位查询数据。</p><span id="more"></span><h2 id="数据库索引的原理可以概括为以下几点"><a href="#数据库索引的原理可以概括为以下几点" class="headerlink" title="数据库索引的原理可以概括为以下几点"></a>数据库索引的原理可以概括为以下几点</h2><ul><li><p><strong>索引是一种数据结构：</strong> 在数据库中，索引是一种特殊的数据结构，它可以使得查询操作更加高效。</p></li><li><p><strong>索引可以加速数据查找：</strong>数据库索引通常会使用一种称为B-树的数据结构来组织数据，这种数据结构可以快速定位需要查询的数据。</p></li><li><p><strong>索引可以提高数据排序的效率：</strong>如果数据库查询需要按照某种方式对数据进行排序，那么使用索引可以显著提高排序的效率。</p></li><li><p><strong>索引可以减少数据库的IO操作：</strong>使用索引可以将需要查询的数据集中在一起，这样可以减少数据库的IO操作，提高查询效率。</p></li></ul><p>总之，数据库索引的原理是利用一种特殊的数据结构，将需要查询的数据组织起来，以便快速地定位和检索数据。通过使用索引，可以提高数据库查询的效率和性能。</p><h2 id="数据库创建索引"><a href="#数据库创建索引" class="headerlink" title="数据库创建索引"></a>数据库创建索引</h2><p>在创建数据库索引时，需要考虑以下几个方面：</p><ul><li><p><strong>索引类型：</strong>需要根据查询场景选择合适的索引类型。常见的索引类型包括B树索引、哈希索引、全文索引等。</p></li><li><p><strong>索引字段：</strong>需要选择适当的字段作为索引。通常情况下，选择经常被查询的字段作为索引字段。但是，在某些情况下，过多的索引字段会降低写入性能，需要进行权衡。</p></li><li><p><strong>索引数量：</strong>需要根据实际情况决定索引数量。过多的索引可能会导致查询优化器选择错误的查询计划，降低查询效率。过少的索引则可能导致查询效率低下。</p></li><li><p><strong>索引顺序：</strong>对于多字段索引，需要选择合适的字段顺序。通常情况下，将最经常被查询的字段放在索引的最左侧。</p></li><li><p><strong>索引覆盖：</strong>需要考虑索引是否覆盖了查询语句所需的所有字段。如果索引无法覆盖所有查询字段，可能需要进行额外的查询操作，降低查询效率。</p></li><li><p><strong>数据库性能：</strong>需要综合考虑索引对数据库性能的影响。在某些情况下，创建索引可能会降低写入性能，需要进行权衡。</p></li></ul><p>综上所述，创建数据库索引需要综合考虑多个因素，需要根据实际情况进行权衡。在实践中，可以通过性能测试和性能优化等手段，进一步优化索引的创建和使用。</p><h2 id="数据库索引和量级的关系"><a href="#数据库索引和量级的关系" class="headerlink" title="数据库索引和量级的关系"></a>数据库索引和量级的关系</h2><p>数据库索引的效率与数据库数量级是有关系的。通常情况下，随着数据库中数据量的增加，查询的效率会逐渐降低。这是因为数据库中的数据越多，查询的结果集也越大，查询所需的时间也会相应地增加。</p><p>在这种情况下，使用索引可以提高查询效率。索引可以通过建立数据结构来加速数据查找。当查询需要访问的数据量较大时，使用索引可以避免扫描整个数据表，提高查询效率。</p><p>但是，随着数据库中数据量的增加，索引的效率也会逐渐降低。这是因为索引需要占用一定的存储空间，而随着数据量的增加，索引所占用的存储空间也会相应地增加。此外，索引也需要维护，维护索引所需的时间也会随着数据量的增加而增加。</p><p>因此，在设计和使用数据库索引时，需要综合考虑数据库的数量级和索引的效率，选择合适的索引类型和索引数量。在实践中，可以通过性能测试和性能优化等手段，进一步优化索引的创建和使用，以提高数据库的查询效率和处理能力。</p><h2 id="MongoDB的索引"><a href="#MongoDB的索引" class="headerlink" title="MongoDB的索引"></a>MongoDB的索引</h2><p>MongoDB的索引是用来加速查询操作的一种数据结构，它可以提高查询效率并降低查询所需的时间。MongoDB支持多种类型的索引，包括B树索引、哈希索引、地理空间索引、全文索引等。</p><p>MongoDB的索引原理可以概括为以下几点：</p><ul><li><p><strong>索引是一种特殊的数据结构：</strong>MongoDB的索引通常使用B树数据结构来实现，每个索引都有一个B树数据结构，包含一个或多个索引键。</p></li><li><p><strong>索引可以加速数据查找：</strong>MongoDB的索引可以帮助查询器快速定位到需要查询的数据，从而提高查询效率。</p></li><li><p><strong>索引可以支持查询优化器：</strong>MongoDB的查询优化器可以利用索引来选择最优的查询计划，从而进一步提高查询效率。</p></li><li><p><strong>索引可以提高数据的排序效率：</strong>如果MongoDB查询需要按照某种方式对数据进行排序，那么使用索引可以显著提高排序的效率。</p></li></ul><p>总之，MongoDB的索引原理是通过使用特殊的数据结构来组织数据，并加速查询操作，从而提高查询效率和性能。使用索引可以减少查询所需的时间，并可以支持查询优化器来选择最优的查询计划。</p><h2 id="MongoDB的B树索引"><a href="#MongoDB的B树索引" class="headerlink" title="MongoDB的B树索引"></a>MongoDB的B树索引</h2><p>在MongoDB中，B树索引是最常用的索引类型之一。B树索引在MongoDB中的实现与传统的B树实现类似，每个节点可以包含多个键值对，并且支持范围查询和排序等操作。</p><p>MongoDB的B树索引的实现原理如下：</p><ul><li><p><strong>索引的结构：</strong>MongoDB的B树索引包括根节点、叶子节点和中间节点。根节点和中间节点存储索引键和子节点的引用，而叶子节点存储索引键和数据记录的引用。</p></li><li><p><strong>索引的构建：</strong>MongoDB的B树索引是通过在数据集上执行sort操作来构建的。构建过程中，MongoDB会扫描集合中的每一条记录，并将索引键和对应的文档ID存储到B树索引中。</p></li><li><p><strong>索引的查询：</strong>MongoDB的B树索引支持基于单个字段或多个字段的查询。查询过程中，MongoDB会遍历B树索引并定位到符合条件的节点，然后返回相应的文档ID或数据记录。</p></li><li><p><strong>索引的优化：</strong>为了提高B树索引的性能，MongoDB会使用预读取和缓存技术来减少磁盘I&#x2F;O操作。此外，MongoDB还支持使用覆盖索引来避免读取数据记录，从而进一步提高查询性能。</p></li></ul><p>总的来说，MongoDB的B树索引是一种基于磁盘的索引类型，它支持范围查询和排序等操作，并且可以通过预读取和缓存技术来提高性能。在MongoDB中，B树索引是最常用的索引类型之一，也是MongoDB高效查询的重要手段之一。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DB </tag>
            
            <tag> Index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Beginning</title>
      <link href="/2023/04/03/New-Start/"/>
      <url>/2023/04/03/New-Start/</url>
      
        <content type="html"><![CDATA[<p>重新开始整理一些东西吧</p><span id="more"></span>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
